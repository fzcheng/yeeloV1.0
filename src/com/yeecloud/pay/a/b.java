package com.yeecloud.pay.a;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.HashMap;import java.util.Iterator;import org.json.JSONException;import org.json.JSONObject;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.widget.Toast;import com.alipay.sdk.app.PayTask;import com.yeecloud.Constant;import com.yeecloud.a.CallResult;import com.yeecloud.a.HttpUtil;import com.yeecloud.pay.k;public class b {	private static b a = new b();	private Activity b;	private k c;	private String d;	private Handler mHandler = new Handler() {		@SuppressWarnings("unused")		public void handleMessage(Message msg) {			String str1 = (String) msg.obj;			switch (msg.what) {			case -1:				Toast.makeText(b, "网络异常", 0).show();				c.a();				break;			case 1:				Toast.makeText(b, str1, 0).show();				c.a();				break;			case 2:				Toast.makeText(b, str1, 0).show();				c.a();				break;			case 3:				Toast.makeText(b, str1, 0).show();				c.a();				break;			case 200: {				PayResult payResult = new PayResult((String) msg.obj);				/**				 * 同步返回的结果必须放置到服务端进行验证（验证的规则请看https://doc.open.alipay.com/doc2/				 * detail.htm?spm=0.0.0.0.xdvAU6&treeId=59&articleId=103665&				 * docType=1) 建议商户依赖异步通知				 */				String resultInfo = payResult.getResult();// 同步返回需要验证的信息				String resultStatus = payResult.getResultStatus();				// 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档				if (TextUtils.equals(resultStatus, "9000")) {					Toast.makeText(b, "支付成功", Toast.LENGTH_SHORT).show();					c.a(d);				} else {					// 判断resultStatus 为非"9000"则代表可能支付失败					// "8000"代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态）					if (TextUtils.equals(resultStatus, "8000")) {						Toast.makeText(b, "支付结果确认中", Toast.LENGTH_SHORT).show();						c.a(d);					} else {						// 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误						Toast.makeText(b, "支付失败", Toast.LENGTH_SHORT).show();						c.a();					}				}				break;			}			default:				break;			}		};	};	public static b a() {		return a;	}	private void a(String paramString) {		this.d = paramString;	}	public void a(Activity paramActivity, final Bundle paramBundle, k paramk) {		this.c = paramk;		this.b = paramActivity;		Runnable payRunnable = new Runnable() {			@Override			public void run() {				HashMap localHashMap = new HashMap();				if (paramBundle != null) {					Iterator localObject1 = paramBundle.keySet().iterator();					while (((Iterator) localObject1).hasNext()) {						String str1 = (String) ((Iterator) localObject1).next();						localHashMap.put(str1, paramBundle.getString(str1));					}				}				CallResult localObject1 = HttpUtil.a(Constant.BASE_URL + "sdk/pay/wsMobilePay.do",						null, localHashMap);				Looper.prepare();				int what = -1;				String localObject2 = "";				Message localMessage = mHandler.obtainMessage();				if (localObject1 != null) {					if (localObject1.a() == 200) {						try {							JSONObject localJSONObject = new JSONObject(									localObject1.b());							int j = localJSONObject.getInt("code");							String str2 = localJSONObject.getString("msg");							String str3 = localJSONObject.getString("orderId");							if (j == 200) {								String payInfo = localJSONObject.getString("payinfo");								System.out.println("payInfo:" + payInfo);								// 构造PayTask 对象								PayTask alipay = new PayTask(b);								// 调用支付接口，获取支付结果								String pstr = new String(Base64.decode(payInfo));																localObject2 = alipay.pay(pstr, true);								a(str3);								what = 200;							} else {								what = 2;								localObject2 = str2;							}						} catch (JSONException localJSONException) {							what = 1;							localObject2 = "数据解析错误";						}					} else {						what = 3;						localObject2 = "服务器请求失败";					}				}				localMessage.what = what;				localMessage.obj = localObject2;				mHandler.sendMessage(localMessage);				Looper.loop();			}		};		// 必须异步调用		Thread payThread = new Thread(payRunnable);		payThread.start();	}	private String b(String paramString) {		try {			return URLDecoder.decode(paramString, "UTF-8");		} catch (UnsupportedEncodingException localUnsupportedEncodingException) {			localUnsupportedEncodingException.printStackTrace();		}		return "";	}}